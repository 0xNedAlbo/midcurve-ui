// Prisma schema file for Midcurve Finance
// Documentation: https://pris.ly/d/prisma-schema

generator client {
  output = "../node_modules/.prisma/client"
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

// Models for concentrated liquidity positions
// Supporting: Uniswap V3 (Ethereum), Orca (Solana), Raydium (Solana), PancakeSwap (BSC)

// =============================================================================
// Authentication Models
// =============================================================================

// AuthAccount - Auth.js adapter model for OAuth/provider accounts
model AuthAccount {
    id                String @id @default(cuid())
    userId            String
    type              String // "credentials" for wallet auth
    provider          String // "siwe" for Ethereum wallets
    providerAccountId String // Wallet address (normalized EIP-55)

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Constraints
    @@unique([provider, providerAccountId])
    @@index([userId])
    @@map("auth_accounts")
}

// AuthSession - Auth.js adapter model for active user sessions
model AuthSession {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Indexes
    @@index([userId])
    @@map("auth_sessions")
}

// AuthVerificationToken - Auth.js adapter model for general-purpose tokens
model AuthVerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    // Constraints
    @@unique([identifier, token])
    @@map("auth_verification_tokens")
}

// AuthWalletAddress - User wallet addresses across multiple EVM chains
model AuthWalletAddress {
    id        String   @id @default(cuid())
    userId    String
    address   String // Normalized (EIP-55 checksum)
    chainId   Int // 1 (Ethereum), 42161 (Arbitrum), 8453 (Base), 56 (BSC), 137 (Polygon), 10 (Optimism)
    isPrimary Boolean  @default(false)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Constraints
    @@unique([address, chainId])
    @@index([userId])
    @@index([address])
    @@map("auth_wallet_addresses")
}

// ApiKey - API keys for programmatic access
model ApiKey {
    id        String    @id @default(cuid())
    userId    String
    name      String // User-friendly name ("Production API", "Dev Testing")
    keyHash   String    @unique // SHA-256 hash of the API key
    keyPrefix String // First 8 chars for display (e.g., "mc_live_")
    lastUsed  DateTime?
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt

    // Relations
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Indexes
    @@index([userId])
    @@index([keyHash])
    @@map("api_keys")
}

// =============================================================================
// Cache & Core Models
// =============================================================================

model Cache {
    key       String   @id
    value     Json
    expiresAt DateTime
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Indexes for efficient queries
    @@index([expiresAt])
    @@map("cache")
}

model User {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // User identification
    name  String?
    email String? @unique
    image String?

    // Auth.js relations
    authAccounts AuthAccount[]
    authSessions AuthSession[]

    // Midcurve auth relations
    walletAddresses AuthWalletAddress[]
    apiKeys         ApiKey[]

    // Midcurve position relations
    positions             Position[]
    quoteTokenPreferences UserQuoteTokenPreference[]

    // Indexes for efficient queries
    @@index([name])
    @@index([email])
    @@map("users")
}

model Token {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Common required fields
    tokenType String // 'evm-erc20' or 'solana-spl'
    name      String
    symbol    String
    decimals  Int

    // Common optional fields
    logoUrl     String?
    coingeckoId String?
    marketCap   Float? // USD market cap from CoinGecko

    // Platform-specific configuration (JSON)
    // Contains address/mint, chainId/programId, platform identifier, etc.
    config Json

    // Relations
    poolsAsToken0 Pool[] @relation("PoolToken0")
    poolsAsToken1 Pool[] @relation("PoolToken1")

    // Indexes for efficient queries
    @@index([tokenType])
    @@index([symbol])
    @@index([coingeckoId])
    @@map("tokens")
}

model Pool {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Common required fields
    protocol String // 'uniswapv3', etc.
    poolType String // 'CL_TICKS'
    token0Id String
    token1Id String
    feeBps   Int // Fee in basis points (3000 = 0.3%)

    // Protocol-specific configuration (JSON) - Immutable
    // Contains pool address, tick spacing, chainId, token addresses, etc.
    config Json

    // Protocol-specific state (JSON) - Mutable
    // Contains current price, liquidity, tick, fee growth, etc.
    // For Uniswap V3: sqrtPriceX96, currentTick, liquidity, feeGrowthGlobal0/1
    state Json

    // Relations to Token model
    // Note: In TypeScript, Pool.token0 and Pool.token1 are full Token objects
    // In database, we use foreign keys for efficient storage and queries
    token0     Token       @relation("PoolToken0", fields: [token0Id], references: [id])
    token1     Token       @relation("PoolToken1", fields: [token1Id], references: [id])
    positions  Position[]
    poolPrices PoolPrice[]

    // Indexes for efficient queries
    @@index([protocol])
    @@index([poolType])
    @@index([token0Id])
    @@index([token1Id])
    @@map("pools")
}

model Position {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Protocol identification
    protocol     String // 'uniswapv3', etc.
    positionType String // 'CL_TICKS'

    // Data ownership
    userId String
    user   User   @relation(fields: [userId], references: [id])

    // Position hash for fast lookups
    // Human-readable composite key: protocol/chainId/nftId (for UniswapV3)
    // Format is protocol-specific, generated by createPositionHash() method
    // Nullable initially for migration, will become required after backfill
    positionHash String? @unique

    // PnL related fields (stored as string for bigint precision)
    currentValue     String // bigint as string
    currentCostBasis String // bigint as string
    realizedPnl      String // bigint as string
    unrealizedPnl    String // bigint as string

    // Cash flow related fields (stored as string for bigint precision)
    collectedFees       String // bigint as string
    unClaimedFees       String // bigint as string
    lastFeesCollectedAt DateTime

    // Price range (stored as string for bigint precision)
    priceRangeLower String // bigint as string
    priceRangeUpper String // bigint as string

    // Pool and token roles
    poolId        String
    pool          Pool    @relation(fields: [poolId], references: [id])
    isToken0Quote Boolean // true: token0 is quote, token1 is base; false: token0 is base, token1 is quote

    // Position state
    positionOpenedAt DateTime
    positionClosedAt DateTime?
    isActive         Boolean

    // Protocol-specific data (JSON)
    config Json // Immutable: chainId, nftId, poolAddress, ticks, etc.
    state  Json // Mutable: ownerAddress, liquidity, feeGrowth, tokensOwed, etc.

    // Relations
    ledgerEvents PositionLedgerEvent[]
    aprPeriods   PositionAprPeriod[]

    // Indexes for efficient queries
    @@index([protocol])
    @@index([positionType])
    @@index([userId])
    @@index([poolId])
    @@index([isActive])
    @@index([userId, positionHash]) // Fast user-specific lookups by hash
    @@map("positions")
}

model PoolPrice {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Protocol identification
    protocol String // 'uniswapv3', etc.

    // Pool reference
    poolId String
    pool   Pool   @relation(fields: [poolId], references: [id])

    // Timestamp when price was recorded
    timestamp DateTime

    // Price fields (stored as string for bigint precision)
    // Price in smallest token units
    token1PricePerToken0 String // bigint as string - How much token1 for 1 token0
    token0PricePerToken1 String // bigint as string - How much token0 for 1 token1

    // Protocol-specific data (JSON)
    config Json // Protocol-specific config (e.g., blockNumber, blockTimestamp for Uniswap V3)
    state  Json // Protocol-specific state (e.g., sqrtPriceX96, tick for Uniswap V3)

    // Indexes for efficient queries
    @@index([protocol])
    @@index([poolId])
    @@index([timestamp])
    @@index([poolId, timestamp]) // Compound index for time-range queries on specific pool
    @@map("pool_prices")
}

model PositionLedgerEvent {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Position reference
    positionId String
    position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

    // Protocol and event chaining
    protocol      String // 'uniswapv3', etc.
    previousId    String? // null for first event
    previousEvent PositionLedgerEvent?  @relation("EventChain", fields: [previousId], references: [id], onDelete: NoAction, onUpdate: NoAction)
    nextEvents    PositionLedgerEvent[] @relation("EventChain")

    // Event identification
    timestamp DateTime // Block timestamp (from blockchain)
    eventType String // 'INCREASE_POSITION', 'DECREASE_POSITION', 'COLLECT'
    inputHash String   @unique // MD5(positionId + blockNumber + txIndex + logIndex)

    // Financial data (stored as string for bigint precision)
    poolPrice    String // bigint as string - Quote tokens per 1 Base token (in smallest units)
    token0Amount String // bigint as string - Token0 amount in smallest units
    token1Amount String // bigint as string - Token1 amount in smallest units
    tokenValue   String // bigint as string - Total value in quote token units
    rewards      Json // Array of {tokenId: string, tokenAmount: string, tokenValue: string}

    // PnL tracking (stored as string for bigint precision)
    deltaCostBasis String // bigint as string - Change in cost basis from this event
    costBasisAfter String // bigint as string - Cumulative cost basis after this event
    deltaPnl       String // bigint as string - Change in realized PnL from this event
    pnlAfter       String // bigint as string - Cumulative realized PnL after this event

    // Protocol-specific data (JSON)
    config Json // Protocol-specific config (blockNumber, txIndex, logIndex, liquidity, fees, etc.)
    state  Json // Raw event data (INCREASE_LIQUIDITY, DECREASE_LIQUIDITY, COLLECT)

    // Indexes for efficient queries
    @@index([positionId, timestamp]) // Time-series queries for position
    @@index([protocol]) // Filter by protocol
    @@index([eventType]) // Filter by event type
    @@index([inputHash]) // Deduplication lookups
    @@index([previousId]) // Event chain traversal
    @@map("position_ledger_events")
}

model PositionAprPeriod {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // Position reference
    positionId String
    position   Position @relation(fields: [positionId], references: [id], onDelete: Cascade)

    // Period boundaries (events that define this period)
    startEventId String // Event that started this period (INCREASE_POSITION or COLLECT)
    endEventId   String // Event that ended this period (next COLLECT or last event)

    // Time range
    startTimestamp  DateTime // When period started
    endTimestamp    DateTime // When period ended (or last event time)
    durationSeconds Int // endTimestamp - startTimestamp (in seconds)

    // Financial metrics (stored as string for bigint precision)
    costBasis         String // Average cost basis during period (in quote token units)
    collectedFeeValue String // Total fees collected during period (in quote token units)

    // APR calculation
    aprBps Int // Annual Percentage Rate in basis points (e.g., 2500 = 25.00%)

    // For debugging/auditing
    eventCount Int // Number of events included in period calculation

    // Indexes for efficient queries
    @@index([positionId, startTimestamp]) // Time-range queries for position
    @@index([positionId, endTimestamp]) // Time-range queries for position
    @@index([aprBps]) // Sort/filter by APR performance
    @@map("position_apr_periods")
}

model UserQuoteTokenPreference {
    id        String   @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // User reference
    userId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

    // Protocol (NO chainId - preferences are protocol-wide)
    // User can have one preference set per protocol
    protocol String // 'uniswapv3', 'orca', 'raydium', etc.

    // Ordered list of preferred quote token identifiers (protocol-specific)
    // - EVM protocols: normalized addresses ["0xA0b8...", "0xC02a..."]
    // - Solana protocols: mint addresses ["EPjFWdd...", "So11111..."]
    // First match wins when both tokens in pair are in this list
    preferredQuoteTokens Json

    // Composite unique constraint and indexes
    @@unique([userId, protocol])
    @@index([userId])
    @@index([protocol])
    @@map("user_quote_token_preferences")
}
